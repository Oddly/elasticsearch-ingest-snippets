# GitHub Actions workflow to validate Elasticsearch ingest pipelines
name: Validate Ingest Pipelines

on:
  push:
    branches: [ "main" ]
  pull_request:
    branches: [ "main" ]

jobs:
  validate:
    runs-on: ubuntu-latest
    
    services:
      elasticsearch:
        image: docker.elastic.co/elasticsearch/elasticsearch:8.10.0
        ports:
          - 9200:9200
        env:
          discovery.type: "single-node"
          xpack.security.enabled: "false"
          ES_JAVA_OPTS: "-Xms512m -Xmx512m"

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Install jq
        run: sudo apt-get install -y jq

      - name: Wait for Elasticsearch to start
        run: |
          echo "Waiting for Elasticsearch to start..."
          timeout 120 bash -c '
          while ! curl -s "http://localhost:9200" > /dev/null; do
            echo -n "."
            sleep 2
          done
          echo "Elasticsearch is responding."
          '

      - name: Wait for Elasticsearch cluster health
        run: |
          echo "Waiting for Elasticsearch cluster to be healthy..."
          timeout 60 bash -c '
          while ! curl -s "http://localhost:9200/_cluster/health?wait_for_status=yellow&timeout=10s" | jq -e ".status == \"green\" or .status == \"yellow\"" > /dev/null; do
            echo -n "."
            sleep 2
          done
          echo "Elasticsearch cluster is healthy."
          '
          curl -s "http://localhost:9200/_cluster/health" | jq '.'

      - name: Determine pipelines to test
        id: changed-pipelines
        run: |
          # This step remains the same...
          set -eo pipefail
          if [ "${{ github.event_name }}" == "pull_request" ]; then
            echo "Detecting changed pipelines in Pull Request..."
            BASE_SHA="${{ github.event.pull_request.base.sha }}"
            HEAD_SHA="${{ github.event.pull_request.head.sha }}"
            CHANGED_FILES=$(git diff --name-only "$BASE_SHA..$HEAD_SHA" -- pipelines/ || echo "")
            if [ -z "$CHANGED_FILES" ]; then
              echo "No pipeline files changed." && echo "test_count=0" >> $GITHUB_OUTPUT && exit 0
            fi
            PIPELINE_DIRS=$(echo "$CHANGED_FILES" | grep "^pipelines/" | cut -d'/' -f1,2 | sort -u || echo "")
            if [ -z "$PIPELINE_DIRS" ]; then
              echo "No pipeline directories changed." && echo "test_count=0" >> $GITHUB_OUTPUT && exit 0
            fi
            PIPELINES_LIST=$(echo "$PIPELINE_DIRS" | tr '\n' ' ' | sed 's/[[:space:]]*$//')
            PIPELINE_COUNT=$(echo "$PIPELINE_DIRS" | wc -l)
            echo "Will test $PIPELINE_COUNT pipeline(s)."
            echo "pipelines_to_test=$PIPELINES_LIST" >> $GITHUB_OUTPUT
            echo "test_count=$PIPELINE_COUNT" >> $GITHUB_OUTPUT
          else
            echo "Running on main branch - testing all pipelines..."
            ALL_PIPELINES=$(find pipelines -type d -mindepth 1 -maxdepth 1 | tr '\n' ' ' | sed 's/[[:space:]]*$//' || echo "")
            PIPELINE_COUNT=$(find pipelines -type d -mindepth 1 -maxdepth 1 | wc -l || echo "0")
            echo "Found $PIPELINE_COUNT total pipeline(s)."
            echo "pipelines_to_test=$ALL_PIPELINES" >> $GITHUB_OUTPUT
            echo "test_count=$PIPELINE_COUNT" >> $GITHUB_OUTPUT
          fi

      - name: Run pipeline validation script
        run: |
          #!/bin/bash
          set -eo pipefail
          
          PIPELINES_TO_TEST="${{ steps.changed-pipelines.outputs.pipelines_to_test }}"
          TEST_COUNT="${{ steps.changed-pipelines.outputs.test_count }}"
          
          if [ "$TEST_COUNT" -eq 0 ]; then
            echo "No pipelines to test - skipping validation."
            exit 0
          fi
          
          echo "Testing $TEST_COUNT pipeline(s)..."
          echo ""
          
          EXIT_CODE=0
          TESTS_RUN=0
          TESTS_PASSED=0
          TESTS_FAILED=0

          read -r -a PIPELINE_ARRAY <<< "$PIPELINES_TO_TEST"

          for dir in "${PIPELINE_ARRAY[@]}"; do
            PIPELINE_FILE="$dir/pipeline.json"
            EXAMPLE_FILE="$dir/simulate_example.json"
            RESULTS_FILE="$dir/simulate_results.json"

            if [ -f "$PIPELINE_FILE" ] && [ -f "$EXAMPLE_FILE" ] && [ -f "$RESULTS_FILE" ]; then
              echo "---"
              echo "[TEST] Testing pipeline in directory: $dir"
              TESTS_RUN=$((TESTS_RUN + 1))

              # FIX: Build the payload by writing raw text to a temporary file.
              # This is the most robust method and avoids all parsing/quoting issues.
              TMP_PAYLOAD_FILE=$(mktemp)
              echo "{" > "$TMP_PAYLOAD_FILE"
              echo '"pipeline":' >> "$TMP_PAYLOAD_FILE"
              cat "$PIPELINE_FILE" >> "$TMP_PAYLOAD_FILE"
              echo ',' >> "$TMP_PAYLOAD_FILE"
              echo '"docs":' >> "$TMP_PAYLOAD_FILE"
              jq '.docs' "$EXAMPLE_FILE" >> "$TMP_PAYLOAD_FILE"
              echo "}" >> "$TMP_PAYLOAD_FILE"
              
              # Use the temporary file directly with curl's @ syntax.
              ACTUAL_RESULT=$(curl -s -X POST "http://localhost:9200/_ingest/pipeline/_simulate" \
                -H "Content-Type: application/json" \
                --data-binary @"$TMP_PAYLOAD_FILE" | jq -S 'del(.. | .timestamp?)')
              
              rm "$TMP_PAYLOAD_FILE" # Clean up

              EXPECTED_RESULT=$(jq -S 'del(.. | .timestamp?)' "$RESULTS_FILE")

              if [[ "$ACTUAL_RESULT" == "$EXPECTED_RESULT" ]]; then
                echo "[SUCCESS] Simulation result matches expected result."
                TESTS_PASSED=$((TESTS_PASSED + 1))
              else
                echo "[FAILURE] Simulation result does not match expected result."
                echo "---------- EXPECTED ----------"
                echo "$EXPECTED_RESULT"
                echo "----------- ACTUAL -----------"
                echo "$ACTUAL_RESULT"
                echo "----------------------------"
                diff --unified <(echo "$EXPECTED_RESULT") <(echo "$ACTUAL_RESULT") || true
                EXIT_CODE=1
                TESTS_FAILED=$((TESTS_FAILED + 1))
              fi
            else
              echo "---"
              echo "[INFO] Skipping directory $dir (missing required .json files for a test)"
            fi
          done

          echo ""
          echo "Test Summary:"
          echo "   Tests run: $TESTS_RUN"
          echo "   Passed: $TESTS_PASSED"
          echo "   Failed: $TESTS_FAILED"
          echo ""

          if [ $EXIT_CODE -ne 0 ]; then
            echo "One or more pipeline tests failed."
          else
            echo "All pipeline tests passed."
          fi
          
          exit $EXIT_CODE
